# 第一章 方法论

现在的程序员写程序几乎没有不依赖操作系统内核的，内核无处不在且略带神秘，在程序员心中慢慢占据了特殊的地位。我们有时为了解决问题不得不靠近它，然而其高度复杂性又使人望而却步。有什么方法能够让普通程序员也能驾驭内核吗？

## 洞察力

Linux内核代码有数百万行，看一本几百万字的小说已经很考验读者，遑论百万行的代码。并且内核的代码并不是线性的，而是相互联系的，这更是增加了内核的复杂性。如果一头扎进源代码，恐怕没游几米远就被淹死了。MIT有一本书专门阐述人类如何掌控复杂性：

> Science and engineering, our modern ways of understanding and altering the world, are said to be about accuracy and precision. Yet we best master the complexity of our world by cultivating insight rather than precision.

科学技术是当代人类理解世界和改造世界的强有力武器。科学技术讲究精确和细节，但是真正帮助人们战胜复杂性的是洞察力。人类依靠洞察力把破碎的知识组成有机的整体，而精确的细节却会使大脑过载。

所以，深入细节决非理解内核的良策。

* X86的分段和分页机制是怎么实现的？
* BIOS的第一条指令在哪个地址？
* 内核的引导扇区怎么被加载进内存，整个内核又是如何run起来的？
* 系统调用的中断号是多少？
* 中断是怎么进入和退出的？

上面的问题就属于细节。不是说细节不重要，但他们不是理解内核的关键所在。如果你把精力都花在这些细节上，那就事倍功半了。我们应该将内核看成一个有机的整体，洞察各个部分之间的逻辑关系。学习内核的时候，似乎总是有股力量能将人的注意力拽到细节上，所以我们要不断地提醒自己：

真正能掌控复杂性的，不是细节，而是洞察。

## 回到原点

我们明白了洞察的重要性，但是作为一个不怎么懂内核的新手，反而要去洞察内核，这不是悖论吗？世界上的知识并不会凭空产生，而是由一系列因素促成。内核也一样，它不是某个人夜观天象，感应上帝，奋战七天七夜而成。内核是进化而来的，人们不断地总结编程经验，思考如何让计算机变得更易用，进而设计出了现在的内核。

我们要回到计算机的源头，尽力发挥逻辑推理、想象力以及同理心，去理解作者为什么作出某种设计。

* 系统调用要怎么实现？
* 怎样才能隔离内核空间与用户空间？
* 为什么要提供进程抽象，怎么抽象？
* 虚拟内存是什么？
* 为什么要用分页机制？
* 用户抢占和内核抢占分别意味着什么，哪里适合作抢占点？

这些问题不能只从源代码中去找答案，而是要想象自己生活在一个没有操作系统的年代，回到计算机的蛮荒岁月，尽力理解内核设计背后的原因。所以，当你陷入内核抽象而繁杂的设计之中时，提醒自己：

勿忘初心，回到原点。

# 第二章 理解CPU

现代计算机架构，是冯诺依曼根据图灵机模型创建的，程序和数据不区分地放在内存中，由CPU存取。我们先认识一下CPU和内存这两个小伙伴

<img src="http://wankai.github.io/images/cpu-memory.png" width="300" height="103" />

## 指令执行

## 原子性

## 乱序执行

