# Why OS

现在的程序员写程序几乎没有不依赖操作系统内核的，内核无处不在且略带神秘，在程序员心中慢慢占据了特殊的地位。我们有时为了解决问题不得不靠近它，然而其高度复杂性又使人望而却步。有什么方法能够让普通程序员也能驾驭内核吗？

## 洞察力

Linux内核代码有数百万行，看一本几百万字的小说已经很考验读者，遑论百万行的代码。并且内核的代码并不是线性的，而是相互联系的，这更是增加了内核的复杂性。如果一头扎进源代码，恐怕没游几米远就被淹死了。MIT有一本书专门阐述人类如何掌控复杂性：

> Science and engineering, our modern ways of understanding and altering the world, are said to be about accuracy and precision. Yet we best master the complexity of our world by cultivating insight rather than precision.

科学技术是当代人类理解世界和改造世界的强有力武器。科学技术讲究精确和细节，但是真正帮助人们战胜复杂性的是洞察力。人类依靠洞察力把破碎的知识组成有机的整体，而精确的细节却会使大脑过载。

所以，深入细节决非理解内核的良策。

* X86的分段和分页机制是怎么实现的？
* BIOS的第一条指令在哪个地址？
* 内核的引导扇区怎么被加载进内存，整个内核又是如何run起来的？
* 系统调用的中断号是多少？
* 中断是怎么进入和退出的？

上面的问题就属于细节。不是说细节不重要，但他们不是理解内核的关键所在。如果你把精力都花在这些细节上，那就事倍功半了。我们应该将内核看成一个有机的整体，洞察各个部分之间的逻辑关系。学习内核的时候，似乎总是有股力量能将人的注意力拽到细节上，所以我们要不断地提醒自己：

真正能掌控复杂性的，不是细节，而是洞察。

## 回到原点

我们明白了洞察的重要性，但是作为一个不怎么懂内核的新手，反而要去洞察内核，这不是悖论吗？世界上的知识并不会凭空产生，而是由一系列因素促成。内核也一样，它不是某个人夜观天象，感应上帝，奋战七天七夜而成。内核是进化而来的，人们不断地总结编程经验，思考如何让计算机变得更易用，进而设计出了现在的内核。

我们要回到计算机的源头，尽力发挥逻辑推理、想象力以及同理心，去理解作者为什么作出某种设计。

* 系统调用要怎么实现？
* 怎样才能隔离内核空间与用户空间？
* 为什么要提供进程抽象，怎么抽象？
* 虚拟内存是什么？
* 为什么要用分页机制？
* 用户抢占和内核抢占分别意味着什么，怎么实现？

这些问题不能只从源代码中去找答案，而是要想想自己生活在一个没有操作系统的年代，回到计算机的蛮荒岁月，尽力理解内核设计背后的原因。所以，当你陷入内核抽象而繁杂的设计之中时，提醒自己：

勿忘初心，回到原点。

# Linux信号面面观

## 引子

1. 为什么CTRL-C能杀死进程，但是有时又杀不死？
2. 为什么下班前在服务器的终端起了一个离线脚本，第二天发现脚本早提前退出了？
3. 为什么我的网络服务崩溃了，好像是什么broken pipe？
4. 为什么read系统调用返回-1时可能会把errno设置为EINTR？非阻塞的read有可能设置EINTR吗？
5. 为什么都说信号处理句柄中的逻辑要尽量简单，最好只设置flag？

这些问题都能回答清楚的话，就不用在这里浪费时间了。如果不是，希望本文能够帮到你。

## 信号是什么？

我觉得学习一门知识最重要的是理解概念，理解到位了通常能用一句话阐述概念的本质。

> 信号是进程在用户空间的异步通信机制

#### 异步

异步通信是信号最本质的特性。异步在这里是指不可预知性，你不知道什么时候会来一个消息。举个例子，你正光着膀子在电脑前看电影，突然听到快递小哥的敲门声，这个不在意料之中的敲门声就是异步信号。

#### 用户空间

信号的响应是在用户空间的。这点虽然不是本质特性，但也很重要，信号的整个机制跟它有关系。如果信号的响应在内核空间呢？呵呵，那就变成中断了。信号和中断在概念上其实是同一个东西，理解其中一个也就明白了另外一个。

## 信号的发送

无论谁都可以发送信号，既可以是别的进程（在中断运行kill命令），也可以是自己（访问内存错误产生segment fault）

